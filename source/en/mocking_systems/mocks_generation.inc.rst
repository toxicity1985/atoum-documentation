
.. _mock_generate_one:

Generate a mock
***************

There are several ways to create a mock from an interface or a class. The simplest one is to create an
object with the absolute name prefixed by ``mock``:

.. code-block:: php

   <?php
   // creation of a mock of the interface \Countable
   $countableMock = new \mock\Countable;

   // creation of a mock from the abstract class
   // \Vendor\Project\AbstractClass
   $vendorAppMock = new \mock\Vendor\Project\AbstractClass;

   // creation of mock of the \StdClass class
   $stdObject     = new \mock\StdClass;

   // creation of a mock from a non-existing class
   $anonymousMock = new \mock\My\Unknown\Claass;

.. _mock_generate_fast:

Generate a mock with newMockInstance
====================================

If you prefer there is method called ``newMockInstance()`` that will generate a mock.

.. code-block:: php

   <?php
   // creation of a mock of the interface \Countable
   $countableMock = new \mock\Countable;

   // is equivalent to
   $this->newMockInstance('Countable');

.. note::
	Like the mock generator, you can give extra parameters: ``$this->newMockInstance('class name', 'mock namespace', 'mock class name', ['constructor args']);``




.. _mock_generator:

The mock generator
******************

atoum relies on a specialised components to generate the mock: the ``mockGenerator``.
You have access to the latter in your tests in order to modify the procedure for the generation of the mocks.

By default, the mock will be generated in the "mock" namespace and behave exactly in the same way as
instances of the original class (mock inherits directly from the original class).

.. _mock_change_name:

Change the name of the class
============================

If you wish to change the name of the class or its namespace, you must use the ``mockGenerator``.

Its ``generate`` method takes 3 parameters:

* the name of the interface or class to mock ;
* the new namespace, optional ;
* the new name of class, optional.

.. code-block:: php

   <?php
   // creation of a mock of the interface \Countable to \MyMock\Countable
   // we only change the namespace
   $this->mockGenerator->generate('\Countable', '\MyMock');

   // creation of a mock from the abstract class
   // \Vendor\Project\AbstractClass to \MyMock\AClass
   // change the namespace and class name
   $this->mockGenerator->generate('\Vendor\Project\AbstractClass', '\MyMock', 'AClass');

   // creation of a mock of \StdClass to \mock\OneClass
   // We only changes the name of the class
   $this->mockGenerator->generate('\StdClass', null, 'OneClass');

   // we can now instantiate these mocks
   $vendorAppMock = new \myMock\AClass;
   $countableMock = new \myMock\Countable;
   $stdObject     = new \mock\OneClass;

.. note::
	If you use only the first argument and do not change the namespace or the name of the class,
	then the first solution is equivalent, easiest to read and recommended.

	You can access to the code from the class generated by the mock generator by calling
	``$this->mockGenerator->getMockedClassCode()``, in order to debug, for example. This
	method takes the same arguments as the method ``generate``.

.. code-block:: php

   <?php
   $countableMock = new \mock\Countable;

   // is equivalent to:

   $this->mockGenerator->generate('\Countable');   // useless
   $countableMock = new \mock\Countable;

.. note::
	All what's described here with the mock generator can be apply with :ref:`newMockInstance<mock_generate_fast>`

.. _mock_shunt_parent_methods:

Shunt calls to parent methods
=============================

.. _mock_shuntParentClassCalls:

shuntParentClassCalls & unShuntParentClassCalls
-----------------------------------------------

A mock inherits from the class from which it was generated, its methods therefore behave exactly the same way.

In some cases, it may be useful to shunt calls to parent methods so that their code is not run.
The ``mockGenerator`` offers several methods to achieve this :

.. code-block:: php

   <?php
   // The mock will not call the parent class
   $this->mockGenerator->shuntParentClassCalls();

   $mock = new \mock\OneClass;

   // the mock will again call the parent class
   $this->mockGenerator->unshuntParentClassCalls();

Here, all mock methods will behave as if they had no implementation however they will keep the signature of the original methods.

.. note::
	``shuntParentClassCalls`` will *only* be applied to the next generated mock. *But* if you create two mock of the same class,
	both will have they parent method shunted.


.. _mock_shunt:

shunt
-----

You can also specify the methods you want to shunt:

.. code-block:: php

   <?php
   // the mock will not call the parent class for the method firstMethodâ€¦...
   $this->mockGenerator->shunt('firstMethod');
   // ... nor for the method secondMethod
   $this->mockGenerator->shunt('secondMethod');

   $countableMock = new \mock\OneClass;

A shunted method, will have empty method body but like for ``shuntParentClassCalls`` the signature of the method will be the same as the mocked method.

.. _mock_orphan_method:

Make an orphan method
=====================

It may be interesting to make an orphan method, that is, give him a signature and implementation empty. This can be
particularly useful for generating mocks without having to instantiate all their dependencies. All the parameters of the method will also set
as default value null. So it's the same a :ref:`shunted method<mock_shunt>`, but with all parameter as null.

.. code-block:: php

   <?php
   class FirstClass {
       protected $dep;

       public function __construct(SecondClass $dep) {
           $this->dep = $dep;
       }
   }

   class SecondClass {
       protected $deps;

       public function __construct(ThirdClass $a, FourthClass $b) {
           $this->deps = array($a, $b);
       }
   }

   $this->mockGenerator->orphanize('__construct');
   $this->mockGenerator->shuntParentClassCalls();

   // We can instantiate the mock without injecting dependencies
   $mock = new \mock\SecondClass();

   $object = new FirstClass($mock);

.. note::
	``orphanize`` will *only* be applied to the next generated mock.

.. _mock_php8_support:

PHP 8.x Support
===============

Since atoum 4.1, the mock generator fully supports modern PHP type declarations, including features introduced in PHP 8.0 and later versions.

Static Return Type
------------------

The mock generator correctly handles the ``static`` return type introduced in PHP 8.0:

.. code-block:: php

   <?php
   class MyClass
   {
       public function getInstance(): static
       {
           return new static();
       }
   }

   // atoum will generate a mock that respects the static return type
   $mock = new \mock\MyClass();
   
   $this
       ->object($mock->getInstance())
           ->isInstanceOf(MyClass::class);

.. note::
   Support for ``static`` return type was added in atoum 4.1.0 (November 2022).

Literal Types (null, true, false)
----------------------------------

Since atoum 4.2.0, the mock generator supports standalone literal types:

.. code-block:: php

   <?php
   class Config
   {
       public function isEnabled(): true
       {
           return true;
       }

       public function getOptionalValue(): null
       {
           return null;
       }

       public function validateStrict(): false
       {
           return false;
       }
   }

   $mock = new \mock\Config();
   
   // The mock will respect the literal return types
   $this
       ->boolean($mock->isEnabled())
           ->isTrue()
       ->variable($mock->getOptionalValue())
           ->isNull()
       ->boolean($mock->validateStrict())
           ->isFalse();

Union and Intersection Types
-----------------------------

atoum 4.x fully supports union types (PHP 8.0) and intersection types (PHP 8.1):

.. code-block:: php

   <?php
   class DataProcessor
   {
       // Union type (PHP 8.0+)
       public function process(int|string $data): array|false
       {
           // ...
       }

       // Intersection type (PHP 8.1+)
       public function validate(Countable&Traversable $collection): bool
       {
           // ...
       }
   }

   $mock = new \mock\DataProcessor();
   
   // Mock methods maintain proper type declarations
   $this
       ->array($mock->process('test'))
       ->boolean($mock->validate(new ArrayIterator([1, 2, 3])));

.. note::
   The mock generator automatically adapts to the PHP version you're using and supports all type declarations available in that version.

Compatibility with self and parent
-----------------------------------

The mock generator correctly handles ``self`` and ``parent`` return types, which were fixed in atoum 4.4.1:

.. code-block:: php

   <?php
   class BaseClass
   {
       public function getParent(): parent
       {
           return parent::getInstance();
       }
   }

   class ChildClass extends BaseClass
   {
       public function getSelf(): self
       {
           return new self();
       }
   }

   $mock = new \mock\ChildClass();
   
   // Return types are properly preserved
   $this
       ->object($mock->getSelf())
           ->isInstanceOf(ChildClass::class);
